

<!DOCTYPE html>
<html>
<head>
	<title>COSC346 Week 5 - Polymorphism</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   	<link rel="stylesheet" type="text/css" href="http://cs.otago.ac.nz/cosc346/labs/phplabbook/labbookswift.css">
	<link rel="stylesheet" type="text/css" href="http://cs.otago.ac.nz/cosc346/labs/cosc346labstyle.css">
	<script src="http://cs.otago.ac.nz/cosc346/labs/jquery-1.11.1.min.js"></script>
	<script src="http://cs.otago.ac.nz/cosc346/labs/toc.min.js"></script>
	<script src="http://cs.otago.ac.nz/cosc346/labs/cosc346labscript.js"></script>
</head>
<body>

	<!-- Banner -->
	<div class="banner">
		<a href="http://cs.otago.ac.nz/cosc346/labs/../labs.php">COSC346 - Object Oriented Programming and User Interfaces</a>
	</div>
		
	<!-- Lab title -->		
	<h1>Week 5&mdash;Polymorphism</h1>
	
	<!-- Table of Contents -->
	<div id="toc"></div>
		
	<h2>Goals</h2>
	<div class="block">
	<ul class="toplist">
		<ul class="toplist">
			<li>To rewrite our Simple Container Library using generics</li>
			<li>To get some practice with the use of protocols</li>
			<li>To create a parser for evaluating fraction and complex number expressions</li>	
		</ul>
	</ul>
	</div>
		
		
	<h2>Preparation</h2>
	<div class="block">
	<ul class="toplist">
		<li>Complete Lab 3&mdash;you'll be using the Fraction and Complex classes from that lab
		<li>Complete Lab 4&mdash;you'll be modifying the Simple Container Library I from that lab
		<li>From Apple's "The Swift Programming Language" read:
		<ul>
			<li><a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html">Protocols</a></li>
			<li><a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html">Generics</a></li>
		</ul>
		</li>
	</ul>
	</div>

	<h2>Simple Container Library III</h2>
	<div class="block">
	
		<p>
		The SCL library you developed in the previous lab is capable of storing objects/items of <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em> type.  In this exercise, you'll be modifying the first version of the library, SCL I, to use generic types in place of the <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em> type.
		</p>
		
	   <h3><em><span class="swiftcode"><span class="swiftclass">Any</span></span></em></h3>
	
		<p>
		In the previous lab, <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em> type was used to refer to a variable that can take any type.  However, <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em> is not really a type&mdash;it's a protocol.  Protocols are a bit like interfaces in Java&mdash;they specify methods, but don't implement them.  In Swift protocols function a bit like abstract classes.  A class that includes a protocol through inheritance relationship must implement the methods listed in the protocol (just like it would if it was inheriting from an abstract class).  An object of such class can up-cast its type to the protocol it inherits from.  Also, multiple inheritance from protocols is allowed in Swift&mdash;there is no <em>diamond of death</em> problem as the methods given by the protocol are all abstract.  <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em> is a protocol that doesn't specify any methods&mdash;any type conforms to that protocol, and so any type can be up-cast to <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em>.  Of course, once up-cast to <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em>, there's not much that the compiler will allow to be done with that object.  The <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em> protocol doesn't specify any methods that can be used on the corresponding object.  That's why objects removed from SCL containers had to be down-cast to their original type in order to invoke their methods.  There will be a bit more about protocols in the second part of this exercise.  In this part, you'll modify SCL library to use a generic type instead of <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em>.
		</p>    
		

	  <h3>Generics</h3>
		
		<p>
		The need for down-casting <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em> to an object's proper type when removing items from SCL containers is quite inelegant.  Coupled with the fact that different types of objects can be stored in the same list, since <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em> works with any type, this makes for an SCL library that is quite prone to errors.  It's possible for a programmer, an SCL library user, to fetch an object from SCL container and force down-casts to an incorrect type, causing a run-time error.  It would be better if there was no need to down-cast at all.  This is exactly the type of problem that <em>generic</em> types are meant to solve.  
		</p>
		
		<p>
		A generic type is kind of a template, a place holder that corresponds to an unspecified type.  This unspecified type can be used in class signatures allowing the object user to specify the type they are after.  
		</p> 

	  <h3>Generic LinkedList</h3>

		
		<p>
		Below is a visualisation of differences between the <em>LinkedList.swift</em> from the previous lab, and one where <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em> is replaced with a generic type.  The code to be removed is shown in red (with a strike line across), and the code to be inserted is shown in blue (underlined).  The usual Swift syntax colouring is turned off to make the differences stand out.  Do not copy and paste this into Xcode&mdash;it will not compile.  What you have to do is to create a new Xcode project and add a copy of <a href="https://raw.githubusercontent.com/oucs-cosc346-s2-2018/lab04-inheritance-and-composition/master/code/01/LinkedList.swift">LinkedList.swift</a> file from the previous lab.  Then, make the changes according to the modifications shown below:
		</p>

		<div class="codeblock">
<div class="codeblocktitle">Differences between two versions of LinkedList.swift </div>
<pre class="filediff">
/**
A list node containing a reference to an object
and a reference to the next node

*/
class Node<ins>&lt;T&gt;</ins> {
    
    // STORED PROPERTIES
    
    var object: <del>Any</del><ins>T</ins>  //Reference to the listed object
    var next : Node<ins>&lt;T&gt;</ins>?       //Optional reference to the next node

    // INITIALISERS
    
    /**
    Designated initialiser
    
    - parameter object: Object referenced by the node
    */
    init(object: <del>Any</del><ins>T</ins>) {
        self.object = object
        // By default, this node
        // doesn't have a next node
        // to point to
        self.next = nil;
    }
}

/**
Linked list of objects

*/
class LinkedList<ins>&lt;U&gt;</ins> : CustomStringConvertible {

    // STORED PROPERTIES

    var head: Node<ins>&lt;U&gt;</ins>?  // Reference to the head node
    var tail: Node<ins>&lt;U&gt;</ins>?  // Reference to the tail node

    // COMPUTED PROPERTIES
    
    /**
    Checks if list is empty
    
    - returns: Bool True if list is empty, false otherwise.
    */
    var empty: Bool {
        if tail != nil {
            return false
        } else {
            return true
        }
    }
    
    /**
    Counts the number of the items in the list
    
    - returns: Int Number of items in the list.
    */
    var count: Int {
        
        var nodeCount: Int = 0
        
        //Starting with the head, walk
        //through the list until the next
        //node points to nil
        var node: Node<ins>&lt;U&gt;</ins>? = head;
        while let n = node {
            //Count the node
            nodeCount += 1
            //Get the reference to the next node
            node = n.next
        }
        
        return nodeCount
    }

    /**
    String representation of the list
    
    - returns: String String representation of the list.
    */
    var description: String {
        
        //The beginning of the list is marked
        //with the left-square bracket
        var descStr: String = &quot;[&quot;

        //Walk through all the nodes and a string
        //representation of each object's contents
        //to descStr
        var node: Node<ins>&lt;U&gt;</ins>? = head
        while let n = node {
            descStr += &quot;\(n.object)&quot;
            node = n.next
            if(node != nil) {
                descStr += &quot;, &quot;
            }
        }
        //Close the description string
        //with the right-square bracket
        descStr += &quot;]&quot;
        return descStr
        
    }
    
    // INITIALISERS
    
    /**
    Designated initialiser

    - parameter list: Linked list to initialise with (nil by default)
    */
    init(list: LinkedList<ins>&lt;U&gt;</ins>? = nil) {
        
        //Set the list to empy
        self.head = nil
        self.tail = nil
        
        //If argument is not nil, then
        //add objects from that list to
        //this one
        if let newList = list {
            var node: Node<ins>&lt;U&gt;</ins>? = newList.head
            while let n = node {
                self.add(object: n.object)
                node = n.next
            }
        }
        
    }
    
    // METHODS

    /**
    Adds an object to the list
    
    - parameter object: Object to add to the list
    */
    func add(object: <del>Any</del><ins>U</ins>) {
        //Create a new node pointing to the
        //object to be added
        let node: Node<ins>&lt;U&gt;</ins> = Node<ins>&lt;U&gt;</ins>(object: object)
        
        //Add the node to the list
        if let t = tail {
            // If list is not empty, point its
            // last node to the new node and
            // point the tail to the new node
            t.next = node
            tail = node
        } else {
            // If list is empty, point the
            // head and tail to the new node
            head = node
            tail = node
        }
    }
    
    /**
    Removes a node from list

    - parameter node: Node to remove from the list
    - returns: Bool True if node found in the list and removed,
            false otherwise.
    */
    func remove(node: Node<ins>&lt;U&gt;</ins>) -&gt; Bool {
        
        var nodeFound = false
        
        //Find the node preceding the one
        //to be removed - list is not double
        //linked, so we need to walk through it
        //form the head until we find the node
        //with next link to the node to be removed
        var prevNode: Node<ins>&lt;U&gt;</ins>? = nil
        var nextNode: Node<ins>&lt;U&gt;</ins>? = head
        while let n = nextNode {
            //Check if next node is the node
            //to be removed...the === is an
            //address comparison operator;
            //the n is the unwrapped
            //optional
            if(n === node) {
                nodeFound = true
                break;
            }
            prevNode = nextNode;
            nextNode = n.next
        }

        
        if nextNode !== node {
            prevNode = nil;
        }
        
        // If node to be removed is
        // the last one in the list,
        // set tail to the previous node,
        if tail === node {
            nodeFound = true
            if let n = prevNode {
                n.next = nil
            }
            tail = prevNode
            prevNode = nil
        }
        
        // If the list is empty,
        // set head to nil as well
        if tail == nil {
            head = nil
        }
        
        // If node to be removed is
        // the first one in the list,
        // set head to the next node
        if head === node {
            nodeFound = true
            head = node.next
        }
        
        // If head points to nil,
        // then we have empty list
        // and need to set tail accordingly
        if head == nil {
            tail = nil
        }
        
        // Relink the node preceeding
        // the one that we are removing
        // to the node following the one
        // that we are removing
        if let n = prevNode {
            n.next = node.next
        }
        
        return nodeFound
    }
    
    /**
    
    Removes all objects from the list

    */
    func removeAll() {
        head = nil
        tail = nil
    }
    
    
    
}
</pre>
</div>

		<p>
		In the new version of <em>LinkedList.swift</em>, <em><span class="swiftcode">Node&lt;T&gt;</span></em> is a class with generic type <em><span class="swiftcode">T</span></em>.  T corresponds to the type of the object referenced by the node.  Note that the "next" property references a node of the same generic type.  This means, nodes can link only to nodes that hold objects of the same type (resulting list must contain items of the same type).  The <em><span class="swiftcode">LinkedList&lt;U&gt;</span></em> is a class with generic type <em><span class="swiftcode">U</span></em>.  The tail and head nodes specify the type of the object contained by these nodes&mdash;that type is U.  So, the <em><span class="swiftcode">T</span></em> in the instances of <em><span class="swiftcode">Node&lt;T&gt;</span></em> created inside <em><span class="swiftcode">LinkedList&lt;U&gt;</span></em> is mapped to generic type <em><span class="swiftcode">U</span></em>. 
		</p>


		<p>Write the following program in <em>main.swift</em>&mdash;it's a modified version of the testing code from the previous lab.  <em><span class="swiftcode">LinkedList</span></em> is now defined as <em><span class="swiftcode">LinkedList&lt;<span class="swiftclass">String</span>&gt;</span></em>.  The new definition maps the generic type <em><span class="swiftcode">U</span></em> to <em><span class="swiftcode">Sring</span></em>.  The instantiated list can hold <em><span class="swiftcode"><span class="swiftclass">String</span></span></em>s only.
		</p> 

		<div class="codeblock">
<div class="codeblocktitle"><a href="code/01/main.swift">main.swift</a></div>
<pre class="linenumbers unselectable" style="float: left;">01:
02:
03:
04:
05:
06:
07:
08:
09:
10:
11:
12:
13:
14:
15:
</pre><pre class="code">
<span class="swiftcode"><span class="swiftkeyword">import</span> Foundation</span>
<span class="swiftcode"></span>
<span class="swiftcode"><span class="swiftkeyword">let</span> str1: <span class="swiftclass">String</span> = <span class="swiftstring">"Item V"</span>;</span>
<span class="swiftcode"><span class="swiftkeyword">let</span> str2: <span class="swiftclass">String</span> = <span class="swiftstring">"Item E"</span>;</span>
<span class="swiftcode"><span class="swiftkeyword">let</span> str3: <span class="swiftclass">String</span> = <span class="swiftstring">"Item S"</span>;</span>
<span class="swiftcode"><span class="swiftkeyword">let</span> str4: <span class="swiftclass">String</span> = <span class="swiftstring">"Item M"</span>;</span>
<span class="swiftcode"></span>
<span class="swiftcode"><span class="swiftkeyword">var</span> list: LinkedList&lt;<span class="swiftclass">String</span>&gt; = LinkedList&lt;<span class="swiftclass">String</span>&gt;()</span>
<span class="swiftcode"><span class="swiftfunction">print</span>(<span class="swiftstring">"</span></span><span class="codeswift">\<span class="swiftstring">(</span>list<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
<span class="swiftcode"></span>
<span class="swiftcode">list.add(object: str1)</span>
<span class="swiftcode">list.add(object: str2)</span>
<span class="swiftcode">list.add(object: str3)</span>
<span class="swiftcode">list.add(object: str4)</span>
<span class="swiftcode"><span class="swiftfunction">print</span>(<span class="swiftstring">"</span></span><span class="codeswift">\<span class="swiftstring">(</span>list<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
</pre>
</div>

		<p>
		Make sure the program compiles and runs&mdash;the output should be exactly the same as it was in the previous lab.
		</p>

	  <h3>Generic Queue</h3>
		
		<p>
		Just like in the previous lab, you'll be implementing other containers.  Grab <a href="https://raw.githubusercontent.com/oucs-cosc346-s2-2018/lab04-inheritance-and-composition/master/code/01/Queue.swift">Queue.swift</a> from the previous lab and add it to the current project.  Modify the code to use the generic type, as shown on the file difference output below.
		</p>


		<div class="codeblock">
<div class="codeblocktitle">Differences between two versions of Queue.swift </div>
<pre class="filediff">
import Foundation
/**
A queue of objects

*/
class Queue<ins>&lt;T&gt;</ins> : LinkedList<ins>&lt;T&gt;</ins> {

    /**
    Queue desription - adds a string indicating the
    container is a queue before invoking super's description
    
    - returns: String String representation of the queue
    */
    override var description: String {
        return &quot;(Queue)&lt;--&quot;+super.description+&quot;&lt;--&quot;
    }
    
<ins>    override init(list: LinkedList&lt;T&gt;? = nil) {
        super.init(list: list)
    }

</ins>    /**
    Puts an an object at the end of the queue
    
    - parameter object: Object to put in the queue.
    */
    func put(object: <del>Any</del><ins>T</ins>) {
        // Use inherited method to add object
        // to the list
        self.add(object: object);
    }
    
    /**
    Gets an an object from the start of the queue
    
    - returns: <del>Any</del><ins>T</ins>? Object removed from the start of the queue,
                nil if queue is empy.
    */
    func get() -&gt; <del>Any</del><ins>T</ins>? {
        // If head points to a non-nil node,
        // remove that node and return its
        // object
        if let n = head {
            //Use inherited method to remove
            //node from the list
            self.remove(node: n)
            return n.object
        } else {
            return nil
        }
    }
}
</pre>
</div>
	
		<p>
		<em><span class="swiftcode">Queue&lt;T&gt;</span></em> inherits from <em><span class="swiftcode">LinkedList&lt;T&gt;</span></em>.  However, inheritance with generic classes is a bit tricky...and for some reason Swift insists that <em><span class="swiftcode">LinkedList&lt;T&gt;</span></em>'s init method cannot be inherited&mdash;it must be overridden.  That's why there's an additional override of the init method, which wraps <em><span class="swiftcode"><span class="swiftkeyword">super</span></span></em>'s init.
		</p>


		<p>Add the test code for the new queue to <em>main.swift</em>.  Again, the code is just a modification from the code in the previous lab.  <em><span class="swiftcode">Queue</span></em> becomes <em><span class="swiftcode">Queue&lt;<span class="swiftclass">String</span>&gt;</span></em>.  This time the object removed from the container does not need to be down-cast, because <em><span class="swiftcode">Queue&lt;<span class="swiftclass">String</span>&gt;</span></em>'s get method returns a <em><span class="swiftcode"><span class="swiftclass">String</span></span></em>.
		</p>

		<div class="codeblock">
<div class="codeblocktitle"><a href="code/01/main.swift">main.swift</a></div>
<pre class="linenumbers unselectable" style="float: left;"><span class="codeold">01:
</span><span class="codeold">02:
</span><span class="codeold">03:
</span><span class="codeold">04:
</span><span class="codeold">05:
</span><span class="codeold">06:
</span><span class="codeold">07:
</span><span class="codeold">08:
</span><span class="codeold">09:
</span><span class="codeold">10:
</span><span class="codeold">11:
</span><span class="codeold">12:
</span><span class="codeold">13:
</span><span class="codeold">14:
</span><span class="codeold">15:
</span><span class="codeold">16:
</span>17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
</pre><pre class="code">
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">import</span> Foundation</span></span>
<span class="codeold"><span class="swiftcode"></span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">let</span> str1: <span class="swiftclass">String</span> = <span class="swiftstring">"Item V"</span>;</span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">let</span> str2: <span class="swiftclass">String</span> = <span class="swiftstring">"Item E"</span>;</span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">let</span> str3: <span class="swiftclass">String</span> = <span class="swiftstring">"Item S"</span>;</span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">let</span> str4: <span class="swiftclass">String</span> = <span class="swiftstring">"Item M"</span>;</span></span>
<span class="codeold"><span class="swiftcode"></span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">var</span> list: LinkedList&lt;<span class="swiftclass">String</span>&gt; = LinkedList&lt;<span class="swiftclass">String</span>&gt;()</span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftfunction">print</span>(<span class="swiftstring">"</span></span><span class="codeswift">\<span class="swiftstring">(</span>list<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span></span>
<span class="codeold"><span class="swiftcode"></span></span>
<span class="codeold"><span class="swiftcode">list.add(object: str1)</span></span>
<span class="codeold"><span class="swiftcode">list.add(object: str2)</span></span>
<span class="codeold"><span class="swiftcode">list.add(object: str3)</span></span>
<span class="codeold"><span class="swiftcode">list.add(object: str4)</span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftfunction">print</span>(<span class="swiftstring">"</span></span><span class="codeswift">\<span class="swiftstring">(</span>list<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span></span>
<span class="codeold"><span class="swiftcode"></span></span>
<span class="swiftcode"><span class="swiftkeyword">var</span> queue: Queue&lt;<span class="swiftclass">String</span>&gt; = Queue&lt;<span class="swiftclass">String</span>&gt;(list: list)</span>
<span class="swiftcode"><span class="swiftfunction">print</span>(<span class="swiftstring">"\n</span></span><span class="codeswift">\<span class="swiftstring">(</span>queue<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
<span class="swiftcode"></span>
<span class="swiftcode"><span class="swiftkeyword">let</span> item1 = queue.<span class="swiftkeyword">get</span>()</span>
<span class="swiftcode"><span class="swiftfunction">print</span>(<span class="swiftstring">"Got item: </span></span><span class="codeswift">\<span class="swiftstring">(</span>item1<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
<span class="swiftcode"><span class="swiftfunction">print</span>(<span class="swiftstring">"</span></span><span class="codeswift">\<span class="swiftstring">(</span>queue<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
<span class="swiftcode"></span>
<span class="swiftcode"><span class="swiftfunction">print</span>(<span class="swiftstring">"Putting item: </span></span><span class="codeswift">\<span class="swiftstring">(</span>str2<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
<span class="swiftcode">queue.put(object: str2)</span>
<span class="swiftcode"><span class="swiftfunction">print</span>(<span class="swiftstring">"</span></span><span class="codeswift">\<span class="swiftstring">(</span>queue<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
</pre>
</div>

		<p>Compile and run; check that it works.</p>
		
 	<h3>Generic Stack and Array</h3>		

		<p>
		Just like in the previous lab, you need to create the stack and array containers yourself&mdash;this time with generic type instead of <em><span class="swiftcode"><span class="swiftclass">Any</span></span></em>.  Implementation of <em><span class="swiftcode">SortableList&lt;T&gt;</span></em> is given to you as well, but again in the difference format from the <a href="https://raw.githubusercontent.com/oucs-cosc346-s2-2018/lab04-inheritance-and-composition/master/code/01/SortableList.swift">SortableList.swift</a> of the previous lab.
		</p>
	
		<div class="codeblock">
<div class="codeblocktitle">Differences between two versions of SortableList.swift </div>
<pre class="filediff">
/**
Extending the node class to provide it with a method
for swapping objects between nodes
*/
extension Node {
    
    /**
    Swaps objects between self and another node nodes - useful for
    sorting - instead of swapping and relinking the nodes, it's easier
    to leave the nodes where they are, and just swap their
    objects
    
    - parameter n Node to swap objects with
    */
    func swapObjectsWith(n: Node<ins>&lt;T&gt;</ins>) {
        let temp: <del>Any</del><ins>T</ins> = self.object
        self.object = n.object
        n.object = temp
    }
}


class SortableList<ins>&lt;T&gt;</ins> : LinkedList<ins>&lt;T&gt;</ins> {
<ins>    
    override init(list: LinkedList&lt;T&gt;? = nil) {
        super.init(list: list)
    }
</ins>    
    /**
    Get the Nth node from the LinkedList
    
    - parameter index: Index of the node to Get
    - returns: Node? The node at the specified index, or nil
    if index exceeds list count
    */
    func getNodeAtIndex(index: Int) -&gt; Node<ins>&lt;T&gt;</ins>? {
        var node: Node<ins>&lt;T&gt;</ins>? = head;
        // Walk through the list until the
        // specified index
        if index &gt; 0 {
            for _ in 1...index {
                if let n = node {
                    node = n.next;
                } else {
                    // Exit early if index
                    // exceeds number of
                    // items on the list
                    return nil;
                }
            }
        }
        return node;
    }
    
    /**
    Sort the list using the provided compare function
    
    - parameter isObject: A function that compares two objects and
    returns true if the first one is smaller than the second one
    
    */
    func sort(isObject: (<del>Any</del><ins>T</ins>, <del>Any</del><ins>T</ins>) -&gt; Bool) {
        
        while true {
            var swap: Bool = false;
            
            var nodeLeft: Node<ins>&lt;T&gt;</ins>? = head
            
            // Walk through the nodes in the list
            while let nLeft = nodeLeft  {
                // Get the next node in the list
                if let nRight = nLeft.next {
                    // Invoked the function that got passed
                    // in as a parameter to check if the
                    // object that follows the current one
                    // on the list is smaller - if yes,
                    // then swap the object of the two nodes
                    if(isObject(nRight.object, nLeft.object)) {
                        nLeft.swapObjectsWith(n: nRight)
                        swap = true
                    }
                }
                nodeLeft = nLeft.next
            }
            
            // Check if anything got swapped in this
            // pass through the entire list - if not,
            // then the entire list has been completely
            // sorted
            if !swap {
                break;
            }
        }
    }
    
}
</pre>
</div>

		<p>
		Once you have an implementation of the generic stack and array container, test it.  You will need to modify the code from previous lab's <a href="https://raw.githubusercontent.com/oucs-cosc346-s2-2018/lab04-inheritance-and-composition/master/code/01/main_05.swift">main.swift</a>.  Some of the changes have been already done in the previous sections of this exercise&mdash;the rest should be pretty straightforward.  In case you're having trouble, here is are the changes (on the entire <em>main.swift</em> file) you're expected to make:

		<div class="codeblock">
<div class="codeblocktitle">Differences between two versions of main.swift </div>
<pre class="filediff">
import Foundation

let str1: String = &quot;Item V&quot;;
let str2: String = &quot;Item E&quot;;
let str3: String = &quot;Item S&quot;;
let str4: String = &quot;Item M&quot;;

var list: LinkedList<ins>&lt;String&gt;</ins> = LinkedList<ins>&lt;String&gt;</ins>()
print(&quot;\(list)&quot;)

list.add(object: str1)
list.add(object: str2)
list.add(object: str3)
list.add(object: str4)
print(&quot;\(list)&quot;)

var queue: Queue<ins>&lt;String&gt;</ins> = Queue<ins>&lt;String&gt;</ins>(list: list)
print(&quot;\n\(queue)&quot;)

<del>if </del>let item1 = queue.get()<del> {</del>
<del>    </del>print(&quot;Got item: \(item1<del> as! String</del>)&quot;)
<del>}
</del>print(&quot;\(queue)&quot;)

print(&quot;Putting item: \(str2)&quot;)
queue.put(object: str2)
print(&quot;\(queue)&quot;)

var stack: Stack<ins>&lt;String&gt;</ins> = Stack<ins>&lt;String&gt;</ins>(list: list)
print(&quot;\n\(stack)&quot;)

<del>if </del>let item2 = stack.pop()<del> {</del>
<del>    </del>print(&quot;Popped item: \(item2<del> as! String</del>)&quot;)
<del>}
</del>print(&quot;\(stack)&quot;)

print(&quot;Pushing item: \(str2)&quot;)
stack.push(object: str2)
print(&quot;\(stack)&quot;)

var array: Array<ins>&lt;String&gt;</ins> = Array<ins>&lt;String&gt;</ins>(list: list)
print(&quot;\n\(array)&quot;)

print(&quot;Setting array[2] to \(str1)&quot;)
array[2] = str1
print(&quot;\(array)&quot;)

print(&quot;Sorting array&quot;);
array.sort(isObject: { o1, o2 in <del>(</del>o1 <del>as! String) </del>&lt; <del>(</del>o2 <del>as! String) </del>})
for index in 0..&lt;array.count {
    print(&quot;array[\(index)]=\(array[index])&quot;)
}
</pre>
</div>
		
	
		<p>Compile and run, check that it works.</p>
	
	</div>	

	<h2>Parsing fractions and complex numbers</h2>
	<div class="block">
	
		<p>
		The SCL library is capable of storing objects of any type, but it does not expect any specific behaviour from them.  Polymorphism becomes much more interesting when the objects of unspecified form are expected to provide certain functionality.  This is where protocols become extremely useful, as they allow definition of the behaviour that generic types are expected to provide.  In this part of the lab, you will be given a <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em>  class that is capable of evaluating mathematical expressions.  The evaluation can be customised by providing the class capable of reading number values from strings.  The provided class will need to implement methods of newly defined protocol.  In this lab, you will modifying <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em> class and <em><span class="swiftcode"><span class="swiftdefined">Complex</span></span></em> class from <a href="https://github.com/oucs-cosc346-s2-2018/lab03-optionals-and-objects">Lab 3</a> to conform to that protocol.
		</p>
		
	  <h3>Parser</h3>
		
		<p>
		Create new Xcode project, name it <em>prog5.2</em>.  The code for the <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em> is given below. Do not type this one out&mdash;it's quite long and complex.  Click on the file link at the top of the box, download it and add to your project.  Some of the file content in the box is highlighted.  In this particular case, the highlighted parts are not meant to mark additions to the code.  The contents of the entire file are given, some parts are made to stand out to aid the discussion that will follow.    
		</p>
		
		<div class="codeblock">
<div class="codeblocktitle"><a href="code/02/Parser.swift">Parser.swift</a></div>
<pre class="linenumbers unselectable" style="float: left;">001:
002:
003:
004:
005:
006:
007:
008:
009:
010:
011:
012:
013:
014:
015:
016:
017:
018:
019:
020:
021:
022:
023:
024:
025:
026:
027:
028:
029:
030:
031:
032:
033:
034:
035:
036:
037:
038:
039:
040:
041:
042:
043:
044:
045:
046:
047:
048:
049:
050:
051:
052:
053:
054:
055:
056:
057:
058:
059:
060:
061:
062:
063:
064:
065:
066:
067:
068:
069:
070:
071:
072:
073:
074:
075:
076:
077:
078:
079:
080:
081:
082:
083:
084:
085:
086:
087:
088:
089:
090:
091:
092:
093:
094:
095:
096:
097:
098:
099:
100:
101:
102:
103:
104:
105:
106:
107:
108:
109:
110:
111:
112:
113:
114:
115:
116:
117:
118:
119:
120:
121:
122:
123:
124:
125:
126:
127:
128:
129:
130:
131:
132:
133:
134:
135:
136:
137:
138:
139:
140:
141:
142:
143:
144:
145:
146:
147:
148:
149:
150:
151:
152:
153:
154:
155:
156:
157:
158:
159:
160:
161:
162:
163:
164:
165:
166:
167:
168:
169:
170:
171:
172:
173:
174:
175:
176:
177:
178:
179:
180:
181:
182:
183:
184:
185:
186:
187:
188:
189:
190:
191:
192:
193:
194:
195:
196:
197:
198:
199:
200:
201:
202:
203:
204:
205:
206:
207:
208:
209:
210:
211:
212:
213:
214:
215:
216:
217:
218:
219:
220:
221:
222:
223:
224:
225:
226:
227:
228:
229:
230:
231:
232:
233:
234:
235:
236:
237:
238:
239:
240:
241:
242:
243:
244:
245:
246:
247:
248:
249:
250:
251:
252:
253:
254:
255:
256:
257:
258:
259:
260:
261:
262:
263:
264:
265:
266:
267:
268:
269:
270:
271:
272:
273:
274:
275:
276:
277:
278:
279:
280:
281:
282:
283:
284:
285:
286:
287:
288:
289:
290:
291:
292:
293:
294:
295:
296:
297:
298:
299:
300:
301:
302:
303:
304:
305:
306:
307:
308:
309:
310:
311:
312:
313:
314:
315:
316:
317:
318:
319:
320:
321:
322:
323:
324:
325:
326:
327:
328:
329:
330:
331:
332:
333:
334:
335:
336:
337:
338:
339:
340:
341:
342:
343:
344:
345:
346:
347:
348:
349:
350:
351:
352:
353:
354:
355:
356:
357:
358:
359:
360:
361:
362:
363:
364:
365:
366:
367:
368:
369:
370:
371:
372:
373:
374:
375:
376:
377:
378:
379:
380:
381:
382:
383:
384:
</pre><pre class="code">
<span class="swiftcode"><span class="swiftkeyword">import</span> Foundation</span>
<span class="swiftcode"></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment">/**</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment"> Protocol for an object that represents</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment"> a number with a function that can convert</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment"> string to that number and has the</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment"> +, -, * and / operations defined</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment"> between two numer objects</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment"> */</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftkeyword">protocol</span> <span class="swiftdefined">StringConvertibleNum</span> {</span></span>
<span class="hilight"><span class="swiftcode">    <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> readFromString(_: <span class="swiftclass">String</span>) -&gt; <span class="swiftclass">Self</span>?</span></span>
<span class="hilight"><span class="swiftcode">    <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> +(_: <span class="swiftclass">Self</span>, _: <span class="swiftclass">Self</span>) -&gt; <span class="swiftclass">Self</span></span></span>
<span class="hilight"><span class="swiftcode">    <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> -(_: <span class="swiftclass">Self</span>,_: <span class="swiftclass">Self</span>) -&gt; <span class="swiftclass">Self</span></span></span>
<span class="hilight"><span class="swiftcode">    <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> *(_: <span class="swiftclass">Self</span>,_: <span class="swiftclass">Self</span>) -&gt; <span class="swiftclass">Self</span></span></span>
<span class="hilight"><span class="swiftcode">    <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> /(_: <span class="swiftclass">Self</span>,_: <span class="swiftclass">Self</span>) -&gt; <span class="swiftclass">Self</span></span></span>
<span class="hilight"><span class="swiftcode">}</span></span>
<span class="swiftcode"></span>
<span class="swiftcode"><span class="swiftcomment">/**</span></span>
<span class="swiftcode"><span class="swiftcomment"> Parser for string expressions with fraction calculations</span></span>
<span class="swiftcode"><span class="swiftcomment"> </span></span>
<span class="swiftcode"><span class="swiftcomment"> Supports +, -, *, and / operations</span></span>
<span class="swiftcode"><span class="swiftcomment"> </span></span>
<span class="swiftcode"><span class="swiftcomment"> */</span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftkeyword">class</span> <span class="swiftdefined">Parser</span>&lt;T: <span class="swiftdefined">StringConvertibleNum</span>&gt; {</span></span>
<span class="swiftcode">    </span>
<span class="swiftcode">    <span class="swiftcomment">// Type alias for operation and string tuple</span></span>
<span class="swiftcode">    <span class="swiftkeyword">typealias</span> <span class="swiftdefined">TokenStr</span> = (op: <span class="swiftclass">Character</span>, token: <span class="swiftclass">String</span>)</span>
<span class="swiftcode">    <span class="swiftcomment">// Type alias for operation and fraction tuple</span></span>
<span class="swiftcode">    <span class="swiftkeyword">typealias</span> <span class="swiftdefined">TokenVal</span> = (op: <span class="swiftclass">Character</span>, token: T)</span>
<span class="swiftcode">    </span>
<span class="swiftcode">    <span class="swiftcomment">/**</span></span>
<span class="swiftcode"><span class="swiftcomment">     Check whether a character corresponds to mathematical</span></span>
<span class="swiftcode"><span class="swiftcomment">     operation symbol</span></span>
<span class="swiftcode"><span class="swiftcomment">     </span></span>
<span class="swiftcode"><span class="swiftcomment">     :param: ch Character to check</span></span>
<span class="swiftcode"><span class="swiftcomment">     - returns: Bool True if character is +,-,/, or *, false</span></span>
<span class="swiftcode"><span class="swiftcomment">     otherwise</span></span>
<span class="swiftcode"><span class="swiftcomment">     */</span></span>
<span class="swiftcode">    <span class="swiftkeyword">private</span> <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> isAnOperation(ch: <span class="swiftclass">Character</span>) -&gt; <span class="swiftclass">Bool</span> {</span>
<span class="swiftcode">        <span class="swiftkeyword">if</span> ch == <span class="swiftstring">"+"</span> || ch == <span class="swiftstring">"-"</span> ||</span>
<span class="swiftcode">            ch == <span class="swiftstring">"/"</span> || ch == <span class="swiftstring">"*"</span> {</span>
<span class="swiftcode">            <span class="swiftkeyword">return</span> <span class="swiftkeyword">true</span>;</span>
<span class="swiftcode">        }</span>
<span class="swiftcode">        <span class="swiftkeyword">return</span> <span class="swiftkeyword">false</span></span>
<span class="swiftcode">    }</span>
<span class="swiftcode">    </span>
<span class="swiftcode">    <span class="swiftcomment">/**</span></span>
<span class="swiftcode"><span class="swiftcomment">     Check whether a string contains a mathematical operation</span></span>
<span class="swiftcode"><span class="swiftcomment">     symbol anywhere aside from the first character</span></span>
<span class="swiftcode"><span class="swiftcomment">     </span></span>
<span class="swiftcode"><span class="swiftcomment">     :param: token String token to check</span></span>
<span class="swiftcode"><span class="swiftcomment">     - returns: Bool True if string token contains a mathematical</span></span>
<span class="swiftcode"><span class="swiftcomment">     operation symbol, false otherwise</span></span>
<span class="swiftcode"><span class="swiftcomment">     */</span></span>
<span class="swiftcode">    <span class="swiftkeyword">private</span> <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> containsOperation(token: <span class="swiftclass">String</span>) -&gt; <span class="swiftclass">Bool</span> {</span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> firstCh: <span class="swiftclass">Bool</span> = <span class="swiftkeyword">true</span>;</span>
<span class="swiftcode">        <span class="swiftkeyword">for</span> ch <span class="swiftkeyword">in</span> token.characters {</span>
<span class="swiftcode">            <span class="swiftkeyword">if</span> firstCh {</span>
<span class="swiftcode">                <span class="swiftcomment">// Do not check the first character of</span></span>
<span class="swiftcode">                <span class="swiftcomment">// the string</span></span>
<span class="swiftcode">                firstCh = <span class="swiftkeyword">false</span></span>
<span class="swiftcode">            } <span class="swiftkeyword">else</span> <span class="swiftkeyword">if</span> isAnOperation(ch: ch) {</span>
<span class="swiftcode">                <span class="swiftkeyword">return</span> <span class="swiftkeyword">true</span>;</span>
<span class="swiftcode">            }</span>
<span class="swiftcode">        }</span>
<span class="swiftcode">        <span class="swiftkeyword">return</span> <span class="swiftkeyword">false</span></span>
<span class="swiftcode">    }</span>
<span class="swiftcode">    </span>
<span class="swiftcode">    <span class="swiftcomment">/**</span></span>
<span class="swiftcode"><span class="swiftcomment">     Tokenises string expression into a set of tupples with</span></span>
<span class="swiftcode"><span class="swiftcomment">     mathematical operation and corresponding number string</span></span>
<span class="swiftcode"><span class="swiftcomment">     </span></span>
<span class="swiftcode"><span class="swiftcomment">     :param: exprStr Expression string to tokenize</span></span>
<span class="swiftcode"><span class="swiftcomment">     - returns: [TokenStr]? An optional array of TokenStr tuples, nil</span></span>
<span class="swiftcode"><span class="swiftcomment">     if parsing returns syntax error at any point</span></span>
<span class="swiftcode"><span class="swiftcomment">     */</span></span>
<span class="swiftcode">    <span class="swiftkeyword">private</span> <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> tokenise(exprStr: <span class="swiftclass">String</span>) -&gt; [<span class="swiftdefined">TokenStr</span>]? {</span>
<span class="swiftcode">        <span class="swiftcomment">// Next token and operation</span></span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> newToken: <span class="swiftclass">String</span> = <span class="swiftstring">""</span></span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> newOperation: <span class="swiftclass">Character</span> = <span class="swiftstring">" "</span></span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// Array of token string tuples to return</span></span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> tokens: [<span class="swiftdefined">TokenStr</span>] = []</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> firstParseChar: <span class="swiftclass">Bool</span> = <span class="swiftkeyword">true</span>;</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// Flag indicating whether operation symbol</span></span>
<span class="swiftcode">        <span class="swiftcomment">// must follow the last token</span></span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> opMustFollow = <span class="swiftkeyword">false</span>;</span>
<span class="swiftcode">        <span class="swiftcomment">// Flag indicating whether operation symbol</span></span>
<span class="swiftcode">        <span class="swiftcomment">// cannot follow the last token</span></span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> opCannotFollow = <span class="swiftkeyword">true</span>;</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// Count checking for bracket closure</span></span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> bracketCount: <span class="swiftclass">Int</span> = <span class="swiftnumber">0</span>;</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// Walk through each character in the expression string</span></span>
<span class="swiftcode">        <span class="swiftkeyword">for</span> exprChar <span class="swiftkeyword">in</span> exprStr.characters {</span>
<span class="swiftcode">            <span class="swiftcomment">// Skip whitespace</span></span>
<span class="swiftcode">            <span class="swiftkeyword">if</span>(exprChar == <span class="swiftstring">" "</span>) {</span>
<span class="swiftcode">                <span class="swiftkeyword">continue</span>;</span>
<span class="swiftcode">            }</span>
<span class="swiftcode">            </span>
<span class="swiftcode">            <span class="swiftcomment">// If the first character in the expression string</span></span>
<span class="swiftcode">            <span class="swiftcomment">// is a "+" or "-", just treat it as</span></span>
<span class="swiftcode">            <span class="swiftcomment">// multiplication by positive or negative 1</span></span>
<span class="swiftcode">            <span class="swiftkeyword">if</span> firstParseChar && (exprChar==<span class="swiftstring">"+"</span> || exprChar==<span class="swiftstring">"-"</span>) {</span>
<span class="swiftcode">                <span class="swiftkeyword">if</span> exprChar == <span class="swiftstring">"-"</span> {</span>
<span class="swiftcode">                    tokens += [(op: <span class="swiftstring">" "</span>, token: <span class="swiftclass">String</span>(exprChar) + <span class="swiftstring">"1"</span>)]</span>
<span class="swiftcode">                    newOperation = <span class="swiftstring">"*"</span></span>
<span class="swiftcode">                }</span>
<span class="swiftcode">                firstParseChar = <span class="swiftkeyword">false</span>;</span>
<span class="swiftcode">                <span class="swiftkeyword">continue</span>;</span>
<span class="swiftcode">            }</span>
<span class="swiftcode">            firstParseChar = <span class="swiftkeyword">false</span></span>
<span class="swiftcode">            </span>
<span class="swiftcode">            <span class="swiftcomment">// If the next parse character does not have to be</span></span>
<span class="swiftcode">            <span class="swiftcomment">// an operation, check for brackets</span></span>
<span class="swiftcode">            <span class="swiftkeyword">if</span> !opMustFollow {</span>
<span class="swiftcode">                </span>
<span class="swiftcode">                <span class="swiftcomment">// If character is the open bracket,</span></span>
<span class="swiftcode">                <span class="swiftcomment">// increase bracket count</span></span>
<span class="swiftcode">                <span class="swiftkeyword">if</span> exprChar == <span class="swiftstring">"("</span> {</span>
<span class="swiftcode">                    <span class="swiftcomment">// If it's the first opening bracket, it must</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// be at the beginning of the new token string</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">if</span> bracketCount == <span class="swiftnumber">0</span> && !newToken.isEmpty {</span>
<span class="swiftcode">                        <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">                    }</span>
<span class="swiftcode">                    bracketCount += <span class="swiftnumber">1</span> </span>
<span class="swiftcode">                    <span class="swiftcomment">// The first open bracket</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// does not get added to the new token</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">if</span>(bracketCount == <span class="swiftnumber">1</span>) {</span>
<span class="swiftcode">                        <span class="swiftkeyword">continue</span>;</span>
<span class="swiftcode">                    }</span>
<span class="swiftcode">                    </span>
<span class="swiftcode">                    <span class="swiftcomment">// Else if parse character is the close bracket,</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// decrease bracket count</span></span>
<span class="swiftcode">                } <span class="swiftkeyword">else</span> <span class="swiftkeyword">if</span> exprChar == <span class="swiftstring">")"</span> {</span>
<span class="swiftcode">                    <span class="swiftcomment">// If bracket count is already at zero</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// there is a syntax error - closing a</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// bracket that hasn't been open</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">if</span>(bracketCount == <span class="swiftnumber">0</span>) {</span>
<span class="swiftcode">                        <span class="swiftkeyword">return</span> nil;</span>
<span class="swiftcode">                    }</span>
<span class="swiftcode">                    bracketCount -= <span class="swiftnumber">1</span> </span>
<span class="swiftcode">                    </span>
<span class="swiftcode">                    <span class="swiftcomment">// Last closing bracket</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// does not get added to the new token string</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// and operation must follow</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">if</span>(bracketCount == <span class="swiftnumber">0</span>) {</span>
<span class="swiftcode">                        opMustFollow = <span class="swiftkeyword">true</span>;</span>
<span class="swiftcode">                        <span class="swiftkeyword">continue</span></span>
<span class="swiftcode">                    }</span>
<span class="swiftcode">                }</span>
<span class="swiftcode">            }</span>
<span class="swiftcode">            </span>
<span class="swiftcode">            <span class="swiftcomment">// If bracket count is at zero, check if the expression character</span></span>
<span class="swiftcode">            <span class="swiftcomment">// is an operation</span></span>
<span class="swiftcode">            <span class="swiftkeyword">if</span> bracketCount == <span class="swiftnumber">0</span> && isAnOperation(ch: exprChar) {</span>
<span class="swiftcode">                </span>
<span class="swiftcode">                <span class="swiftcomment">// Next character is an operation</span></span>
<span class="swiftcode">                </span>
<span class="swiftcode">                <span class="swiftkeyword">if</span> opCannotFollow || newToken.isEmpty {</span>
<span class="swiftcode">                    <span class="swiftcomment">// If the flag for operation cannot follow is set or the</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// token string is empty (operation follows right after</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// an operation), then we have a parse error</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">                } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">                    <span class="swiftcomment">// Add a new tuple to the return token array</span></span>
<span class="swiftcode">                    tokens += [(op: newOperation, token: newToken)]</span>
<span class="swiftcode">                    <span class="swiftcomment">// Reset the string token</span></span>
<span class="swiftcode">                    newToken = <span class="swiftstring">""</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// Save the operation for next tuple</span></span>
<span class="swiftcode">                    newOperation = exprChar;</span>
<span class="swiftcode">                    <span class="swiftcomment">// Reset operation must/cannot follow flags</span></span>
<span class="swiftcode">                    opMustFollow = <span class="swiftkeyword">false</span></span>
<span class="swiftcode">                    opCannotFollow = <span class="swiftkeyword">true</span></span>
<span class="swiftcode">                }</span>
<span class="swiftcode">            } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">                <span class="swiftcomment">// Next character is not an operation</span></span>
<span class="swiftcode">                </span>
<span class="swiftcode">                <span class="swiftkeyword">if</span> opMustFollow {</span>
<span class="swiftcode">                    <span class="swiftcomment">// If operation must follow, we got a</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// syntax error</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">                }</span>
<span class="swiftcode">                <span class="swiftcomment">// Just add expression character to the</span></span>
<span class="swiftcode">                <span class="swiftcomment">// token string</span></span>
<span class="swiftcode">                newToken.append(exprChar);</span>
<span class="swiftcode">                <span class="swiftcomment">// Operation can follow after a non-operation</span></span>
<span class="swiftcode">                <span class="swiftcomment">//character</span></span>
<span class="swiftcode">                opCannotFollow = <span class="swiftkeyword">false</span></span>
<span class="swiftcode">            }</span>
<span class="swiftcode">        }</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// Add the remaining operation and the token string</span></span>
<span class="swiftcode">        tokens += [(op: newOperation, token: newToken)]</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// Finished parsing the expression string, if bracket count</span></span>
<span class="swiftcode">        <span class="swiftcomment">// is not zero, we have a syntax error</span></span>
<span class="swiftcode">        <span class="swiftkeyword">if</span> bracketCount &gt; <span class="swiftnumber">0</span> {</span>
<span class="swiftcode">            <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">        } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">            <span class="swiftkeyword">return</span> tokens</span>
<span class="swiftcode">        }</span>
<span class="swiftcode">    }</span>
<span class="swiftcode">    </span>
<span class="swiftcode">    <span class="swiftcomment">/**</span></span>
<span class="swiftcode"><span class="swiftcomment">     Evaluates a string as a mathematical expression.</span></span>
<span class="swiftcode"><span class="swiftcomment">     </span></span>
<span class="swiftcode"><span class="swiftcomment">     :param: string String to evaluate</span></span>
<span class="swiftcode"><span class="swiftcomment">     :param: debug Flag indicating whether to print debug info</span></span>
<span class="swiftcode"><span class="swiftcomment">     :param: rcount Recursion count - used for indentation printing of debug info</span></span>
<span class="swiftcode"><span class="swiftcomment">     :return: Fraction? Result of evaluation the string, nil if syntax error</span></span>
<span class="swiftcode"><span class="swiftcomment">     */</span></span>
<span class="swiftcode">    <span class="swiftkeyword">private</span> <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> evaluate(string: <span class="swiftclass">String</span>, debug: <span class="swiftclass">Bool</span>, rcount: <span class="swiftclass">Int</span>) -&gt; T? {</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// Debug display</span></span>
<span class="swiftcode">        <span class="swiftkeyword">if</span> debug {</span>
<span class="swiftcode">            <span class="swiftfunction">print</span>(<span class="swiftstring">"dbg:"</span>, terminator: <span class="swiftstring">""</span>)</span>
<span class="swiftcode">            <span class="swiftkeyword">for</span> _ <span class="swiftkeyword">in</span> <span class="swiftnumber">0</span>..&lt;rcount {</span>
<span class="swiftcode">                <span class="swiftfunction">print</span>(<span class="swiftstring">"| "</span>, terminator: <span class="swiftstring">""</span>)</span>
<span class="swiftcode">            }</span>
<span class="swiftcode">        }</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// Check for base case</span></span>
<span class="swiftcode">        <span class="swiftkeyword">if</span> !containsOperation(token: string) {</span>
<span class="swiftcode">            <span class="swiftcomment">// There are no more mathematical operators within the string -</span></span>
<span class="swiftcode">            <span class="swiftcomment">// just evaluate the string to Fraction</span></span>
<span class="hilight"><span class="swiftcode">            <span class="swiftkeyword">let</span> result =  T.readFromString(string)</span></span>
<span class="swiftcode">            </span>
<span class="swiftcode">            <span class="swiftcomment">// Debug info</span></span>
<span class="swiftcode">            <span class="swiftkeyword">if</span> debug {</span>
<span class="swiftcode">                <span class="swiftkeyword">if</span> <span class="swiftkeyword">let</span> f = result {</span>
<span class="swiftcode">                    <span class="swiftfunction">print</span>(<span class="swiftstring">"evaluating number </span></span><span class="codeswift">\<span class="swiftstring">(</span>f<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
<span class="swiftcode">                } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">                    <span class="swiftfunction">print</span>(<span class="swiftstring">"syntax error!"</span>)</span>
<span class="swiftcode">                }</span>
<span class="swiftcode">            }</span>
<span class="swiftcode">            </span>
<span class="swiftcode">            <span class="swiftkeyword">return</span> result</span>
<span class="swiftcode">        } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">            <span class="swiftcomment">// There are mathematical expressions within the string -</span></span>
<span class="swiftcode">            <span class="swiftcomment">// will parse the string and break it into substrings</span></span>
<span class="swiftcode">            <span class="swiftcomment">// and recursively evaluate each part</span></span>
<span class="swiftcode">            </span>
<span class="swiftcode">            <span class="swiftcomment">// Break the string into string tokens separated</span></span>
<span class="swiftcode">            <span class="swiftcomment">// by mathematical symbols</span></span>
<span class="swiftcode">            <span class="swiftkeyword">let</span> tokensToParse: [<span class="swiftdefined">TokenStr</span>]? = <span class="swiftdefined">Parser</span>&lt;T&gt;.tokenise(exprStr: string);</span>
<span class="swiftcode">            </span>
<span class="swiftcode">            <span class="swiftcomment">// Check if parsing retunred non-nil result</span></span>
<span class="swiftcode">            <span class="swiftkeyword">if</span> <span class="swiftkeyword">let</span> tokens = tokensToParse {</span>
<span class="swiftcode">                </span>
<span class="swiftcode">                <span class="swiftcomment">// Debug info about tokens found</span></span>
<span class="swiftcode">                <span class="swiftkeyword">if</span> debug {</span>
<span class="swiftcode">                    <span class="swiftfunction">print</span>(<span class="swiftstring">"evaluating '</span></span><span class="codeswift">\<span class="swiftstring">(</span>string<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">'"</span>)</span>
<span class="swiftcode">                    <span class="swiftkeyword">for</span> token <span class="swiftkeyword">in</span> tokens {</span>
<span class="swiftcode">                        <span class="swiftfunction">print</span>(<span class="swiftstring">"dbg:"</span>, terminator: <span class="swiftstring">""</span>)</span>
<span class="swiftcode">                        <span class="swiftkeyword">for</span> _ <span class="swiftkeyword">in</span> <span class="swiftnumber">0</span>..&lt;rcount {</span>
<span class="swiftcode">                            <span class="swiftfunction">print</span>(<span class="swiftstring">"| "</span>, terminator: <span class="swiftstring">""</span>)</span>
<span class="swiftcode">                        }</span>
<span class="swiftcode">                        <span class="swiftfunction">print</span>(<span class="swiftstring">"found op:</span></span><span class="codeswift">\<span class="swiftstring">(</span>token.op<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">, expr:</span></span><span class="codeswift">\<span class="swiftstring">(</span>token.token<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
<span class="swiftcode">                    }</span>
<span class="swiftcode">                }</span>
<span class="swiftcode">                </span>
<span class="swiftcode">                <span class="swiftcomment">// Start converting strings to values</span></span>
<span class="swiftcode">                <span class="swiftkeyword">var</span> valuesToProcess: [<span class="swiftdefined">TokenVal</span>] = [];</span>
<span class="swiftcode">                </span>
<span class="swiftcode">                <span class="swiftcomment">// Evaluate all tokens to numbers</span></span>
<span class="swiftcode">                <span class="swiftkeyword">for</span> token <span class="swiftkeyword">in</span> tokens {</span>
<span class="swiftcode">                    <span class="swiftcomment">// Recursive call to evaluate next token to a value</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">if</span> <span class="swiftkeyword">let</span> val = <span class="swiftkeyword">self</span>.evaluate(string: token.token, debug: debug, rcount: rcount+<span class="swiftnumber">1</span>) {</span>
<span class="swiftcode">                        <span class="swiftcomment">// Debug info showing obtained value</span></span>
<span class="swiftcode">                        <span class="swiftkeyword">if</span> debug {</span>
<span class="swiftcode">                            <span class="swiftfunction">print</span>(<span class="swiftstring">"dbg:"</span>, terminator: <span class="swiftstring">""</span>)</span>
<span class="swiftcode">                            <span class="swiftkeyword">for</span> _ <span class="swiftkeyword">in</span> <span class="swiftnumber">0</span>..&lt;rcount+<span class="swiftnumber">1</span> {</span>
<span class="swiftcode">                                <span class="swiftfunction">print</span>(<span class="swiftstring">"| "</span>, terminator: <span class="swiftstring">""</span>)</span>
<span class="swiftcode">                            }</span>
<span class="swiftcode">                            <span class="swiftfunction">print</span>(<span class="swiftstring">"value: </span></span><span class="codeswift">\<span class="swiftstring">(</span>val<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
<span class="swiftcode">                        }</span>
<span class="swiftcode">                        <span class="swiftcomment">// Add the operator with the new value</span></span>
<span class="swiftcode">                        <span class="swiftcomment">// to the parsed values array</span></span>
<span class="swiftcode">                        valuesToProcess += [(op: token.op,token: val)]</span>
<span class="swiftcode">                    } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">                        <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">                    }</span>
<span class="swiftcode">                }</span>
<span class="swiftcode">                </span>
<span class="swiftcode">                <span class="swiftcomment">// If no values were found, return nil</span></span>
<span class="swiftcode">                <span class="swiftkeyword">if</span> valuesToProcess.isEmpty {</span>
<span class="swiftcode">                    <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">                }</span>
<span class="swiftcode">                </span>
<span class="swiftcode">                <span class="swiftcomment">// The first value in the array should</span></span>
<span class="swiftcode">                <span class="swiftcomment">// came with no preceeding operation</span></span>
<span class="swiftcode">                <span class="swiftkeyword">let</span> firstToken = valuesToProcess[<span class="swiftnumber">0</span>]</span>
<span class="swiftcode">                <span class="swiftkeyword">if</span> firstToken.op != <span class="swiftstring">" "</span> {</span>
<span class="swiftcode">                    <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">                }</span>
<span class="swiftcode">                </span>
<span class="swiftcode">                </span>
<span class="swiftcode">                <span class="swiftcomment">// The * and / have precendence over + and</span></span>
<span class="swiftcode">                <span class="swiftcomment">// -, so first evaluate all the * and /</span></span>
<span class="swiftcode">                <span class="swiftcomment">// operators in the valuesToProcess array</span></span>
<span class="swiftcode">                <span class="swiftkeyword">var</span> i: <span class="swiftclass">Int</span> = <span class="swiftnumber">1</span>;</span>
<span class="swiftcode">                <span class="swiftkeyword">while</span> i &lt; valuesToProcess.count {</span>
<span class="swiftcode">                    <span class="swiftcomment">// Get the operation, the left operand</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// value and the right operand value</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">let</span> op = valuesToProcess[i].op</span>
<span class="hilight"><span class="swiftcode">                    <span class="swiftkeyword">let</span> leftNum: T = valuesToProcess[i-<span class="swiftnumber">1</span>].token</span></span>
<span class="hilight"><span class="swiftcode">                    <span class="swiftkeyword">let</span> rightNum: T = valuesToProcess[i].token</span></span>
<span class="swiftcode">                    </span>
<span class="swiftcode">                    <span class="swiftcomment">// If the operations is a * or a /, then</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// perform multiplication or division, replacing</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// the left operand in the valuesToProcess with</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// the result, removing the right operand</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">if</span> op == <span class="swiftstring">"*"</span> {</span>
<span class="hilight"><span class="swiftcode">                        valuesToProcess[i-<span class="swiftnumber">1</span>].token=leftNum * rightNum</span></span>
<span class="swiftcode">                        valuesToProcess.remove(at: i);</span>
<span class="swiftcode">                    } <span class="swiftkeyword">else</span> <span class="swiftkeyword">if</span> op == <span class="swiftstring">"/"</span> {</span>
<span class="hilight"><span class="swiftcode">                        valuesToProcess[i-<span class="swiftnumber">1</span>].token=leftNum / rightNum</span></span>
<span class="swiftcode">                        valuesToProcess.remove(at: i);</span>
<span class="swiftcode">                    } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">                        i += <span class="swiftnumber">1</span>;</span>
<span class="swiftcode">                    }</span>
<span class="swiftcode">                }</span>
<span class="swiftcode">                </span>
<span class="swiftcode">                <span class="swiftcomment">// Once multiplication and division is done,</span></span>
<span class="swiftcode">                <span class="swiftcomment">// it's time to do addition and subtraction.</span></span>
<span class="swiftcode">                <span class="swiftcomment">// The result is stored as a single result</span></span>
<span class="swiftcode">                <span class="swiftcomment">// value</span></span>
<span class="hilight"><span class="swiftcode">                <span class="swiftkeyword">var</span> result: T = valuesToProcess[<span class="swiftnumber">0</span>].token</span></span>
<span class="swiftcode">                <span class="swiftkeyword">for</span> i <span class="swiftkeyword">in</span> <span class="swiftnumber">1</span>..&lt;valuesToProcess.count {</span>
<span class="swiftcode">                    <span class="swiftkeyword">let</span> token = valuesToProcess[i]</span>
<span class="hilight"><span class="swiftcode">                    <span class="swiftkeyword">let</span> num: T = token.token</span></span>
<span class="swiftcode">                    </span>
<span class="swiftcode">                    <span class="swiftcomment">// Check if the operation on the next</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// token is + or - and perform</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// addition or subtraction on</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// the final result and the next token</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">if</span> token.op == <span class="swiftstring">"+"</span> {</span>
<span class="hilight"><span class="swiftcode">                        result = result + num;</span></span>
<span class="swiftcode">                    } <span class="swiftkeyword">else</span> <span class="swiftkeyword">if</span>(token.op == <span class="swiftstring">"-"</span>) {</span>
<span class="hilight"><span class="swiftcode">                        result = result - num;</span></span>
<span class="swiftcode">                    } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">                        <span class="swiftcomment">// Do not expect any other operations</span></span>
<span class="swiftcode">                        <span class="swiftcomment">// at this point, aside from + and -,</span></span>
<span class="swiftcode">                        <span class="swiftcomment">// so if something else is found,</span></span>
<span class="swiftcode">                        <span class="swiftcomment">// return nil</span></span>
<span class="swiftcode">                        <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">                    }</span>
<span class="swiftcode">                    </span>
<span class="swiftcode">                    <span class="swiftcomment">// Debug display of the final result</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">if</span> debug {</span>
<span class="swiftcode">                        <span class="swiftfunction">print</span>(<span class="swiftstring">"dbg:"</span>, terminator: <span class="swiftstring">""</span>)</span>
<span class="swiftcode">                        <span class="swiftkeyword">for</span> _ <span class="swiftkeyword">in</span> <span class="swiftnumber">0</span>..&lt;rcount {</span>
<span class="swiftcode">                            <span class="swiftfunction">print</span>(<span class="swiftstring">"| "</span>, terminator: <span class="swiftstring">""</span>)</span>
<span class="swiftcode">                        }</span>
<span class="swiftcode">                        <span class="swiftfunction">print</span>(<span class="swiftstring">"total: </span></span><span class="codeswift">\<span class="swiftstring">(</span>result<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
<span class="swiftcode">                    }</span>
<span class="swiftcode">                }</span>
<span class="swiftcode">                <span class="swiftcomment">// Return the evaluated result</span></span>
<span class="swiftcode">                <span class="swiftkeyword">return</span> result;</span>
<span class="swiftcode">            } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">                <span class="swiftcomment">// This else catches the nil return</span></span>
<span class="swiftcode">                <span class="swiftcomment">// of the parse result, meaning</span></span>
<span class="swiftcode">                <span class="swiftcomment">// parsing didn't work because of</span></span>
<span class="swiftcode">                <span class="swiftcomment">// a syntax error</span></span>
<span class="swiftcode">                <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">            }</span>
<span class="swiftcode">        }</span>
<span class="swiftcode">    }</span>
<span class="swiftcode">    </span>
<span class="hilight"><span class="swiftcode">    <span class="swiftcomment">/**</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment">     Evaluates a string as a mathematical expression.</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment">     </span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment">     :param: string String to evaluate</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment">     :param: debug Flag indicating whether to print debug info (false by default)</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment">     :return: Fraction? Result of evaluation the string, nil if syntax error</span></span></span>
<span class="hilight"><span class="swiftcode"><span class="swiftcomment">     */</span></span></span>
<span class="hilight"><span class="swiftcode">    <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> evaluate(string: <span class="swiftclass">String</span>, withDebugOption: <span class="swiftclass">Bool</span> = <span class="swiftkeyword">false</span>) -&gt; T? {</span></span>
<span class="hilight"><span class="swiftcode">        <span class="swiftkeyword">return</span> <span class="swiftdefined">Parser</span>&lt;T&gt;.evaluate(string: string, debug: withDebugOption, rcount: <span class="swiftnumber">0</span>);</span></span>
<span class="hilight"><span class="swiftcode">    }</span></span>
<span class="swiftcode">}</span>
</pre>
</div>

	  <h3>StringConvertibleNum</h3>

		<p>
		At the top of <em>Parser.swift</em>, a new protocol, <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em>, is defined.  It lists four methods returning <em><span class="swiftcode"><span class="swiftclass">Self</span></span></em>.  <em><span class="swiftcode"><span class="swiftclass">Self</span></span></em> is a special type that corresponds to the type of the class implementing the protocol.  In other words, a class that conforms to this protocol will have to implement methods returning objects of its own type.  The first method is a class method that converts a <em><span class="swiftcode"><span class="swiftclass">String</span></span></em> to an object of that class.  It returns an optional of that type, in case the conversion is not successful.  The other methods correspond to the addition, subtraction, multiplication and division operators between objects of the class type, returning resulting objects of the class type.  A class conforming to <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em> is meant to correspond to a number that can be read from string as well as it being able to be added to, subtracted from, multiplied and divided by another number object of the same type.
		</p>

	  <h3>Generic with constraints</h3>
	
		<p>
		Take a look at the signature of the class&mdash;"<em><span class="swiftcode"><span class="swiftkeyword">class</span> <span class="swiftdefined">Parser</span>&lt;T: <span class="swiftdefined">StringConvertibleNum</span>&gt;</span></em>".  <em><span class="swiftcode">T</span></em> is a generic type, but it's followed by a colon with a protocol name.  This means that only classes that conform to the specified protocol, in this case <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em>, can be mapped to this generic type.  Since this constraint ensures that the generic type conforms to <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em>, the methods of that protocol can be used safely on <em><span class="swiftcode">T</span></em>, as shown in the code above, in the private version of the <em><span class="swiftcode">evaluate</span></em> method.  
		</p>
		
	   <h3>Interface</h3>
		
		<p>
		The <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em> class has no stored properties and all its methods are static&mdash;therefore, there is no need to instantiate it.  The only non-private method is the <em><span class="swiftcode">evaluate</span></em> method at the bottom.  Its signature is "<em><span class="swiftcode"><span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> evaluate(string: <span class="swiftclass">String</span>, withDebugOption: <span class="swiftclass">Bool</span> = <span class="swiftkeyword">false</span>) -&gt; T?</span></em>".  It wraps a private method that requires an extra argument&mdash;the wrapping assures that user does not set the extra argument to the wrong value.  This wrapping method can be invoked with just one argument, the string to evaluate, or with additional parameter that enables debug printing (disabled by default).  The returned object is an optional of the generic type. It's either the result of the evaluation, or <em><span class="swiftcode">nil</span></em> in the case when the parser encounters a syntax error.   
		</p>

	   <h3>Parsing fractions</h3>

		<p>Grab your latest implementation of <em>Fraction.swift</em> from <a href="https://github.com/oucs-cosc346-s2-2018/lab03-optionals-and-objects">Lab 3</a> and add the file to your current project.  You'll notice that the class already conforms to the four out of five methods of the <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em> protocol&mdash;it defines the +,-,* and / operators between two <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em>s.  In order to conform to <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em> <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em> needs to also implement a <em><span class="swiftcode">readFromString</span></em> method.  Below you can find an implementation of that method.  It can read strings of the format "a" and "a/b" as fractions "a/1" and "a/b" respectively (the "a" and "b" must be integers).  Add this method to your implementation of <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em>.  Also, make sure to add the <em><span class="swiftcode"><span class="swiftkeyword">final</span></span></em> keyword, as well as the <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em> to the class signature (as shown below).
		</p>
		
		<div class="codeblock">
<div class="codeblocktitle"><a href="code/02/Fraction.swift">Fraction.swift</a></div>
<pre class="linenumbers unselectable" style="float: left;">01:
02:
03:
04:
05:
06:
07:
08:
09:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44:
45:
46:
47:
48:
49:
50:
51:
52:
53:
54:
55:
56:
</pre><pre class="code">
<span class="swiftcode"><span class="swiftkeyword">import</span> Foundation</span>
<span class="swiftcode"></span>
<span class="swiftcode"><span class="swiftcomment">/**</span></span>
<span class="swiftcode"><span class="swiftcomment">Represents a number as a fraction of two integers</span></span>
<span class="swiftcode"><span class="swiftcomment"></span></span>
<span class="swiftcode"><span class="swiftcomment">*/</span></span>
<span class="swiftcode"><span class="swiftkeyword">final</span> <span class="swiftkeyword">class</span> <span class="swiftdefined">Fraction</span> : <span class="swiftclass">CustomStringConvertible</span>, <span class="swiftdefined">StringConvertibleNum</span> {</span>
<span class="swiftcode">    </span>
<span class="swiftcode">    <span class="swiftcomment">/**</span></span>
<span class="swiftcode"><span class="swiftcomment">    Converts string to a Fraction object.  Supports string</span></span>
<span class="swiftcode"><span class="swiftcomment">    syntax of the following format:</span></span>
<span class="swiftcode"><span class="swiftcomment">    "a" - converts it to fraction a/1</span></span>
<span class="swiftcode"><span class="swiftcomment">    "a/b" - converts it to fraction a/b</span></span>
<span class="swiftcode"><span class="swiftcomment">    </span></span>
<span class="swiftcode"><span class="swiftcomment">    - parameter string: String to convert</span></span>
<span class="swiftcode"><span class="swiftcomment">    - returns: Fraction? Fraction read from string, nil if</span></span>
<span class="swiftcode"><span class="swiftcomment">    syntax error in the string</span></span>
<span class="swiftcode"><span class="swiftcomment">    */</span></span>
<span class="swiftcode">    <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> readFromString(_ string: <span class="swiftclass">String</span>) -&gt; <span class="swiftdefined">Fraction</span>? {</span>
<span class="swiftcode">        <span class="swiftcomment">// Default values for numerator</span></span>
<span class="swiftcode">        <span class="swiftcomment">// and denomintor</span></span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> num: <span class="swiftclass">Int</span> = <span class="swiftnumber">0</span>;</span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> den: <span class="swiftclass">Int</span> = <span class="swiftnumber">1</span>;</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// Break the string into tokens separated by / symbol</span></span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> tokens = string.components(separatedBy: <span class="swiftstring">"/"</span>)</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// If there is at least one token, then there is</span></span>
<span class="swiftcode">        <span class="swiftcomment">// a numerator value</span></span>
<span class="swiftcode">        <span class="swiftkeyword">if</span> tokens.count &gt; <span class="swiftnumber">0</span> {</span>
<span class="swiftcode">            <span class="swiftcomment">// Try to convert numerator string to integer -</span></span>
<span class="swiftcode">            <span class="swiftcomment">// if not successful, return nil</span></span>
<span class="swiftcode">            <span class="swiftkeyword">if</span> <span class="swiftkeyword">let</span> n = <span class="swiftclass">Int</span>(tokens[<span class="swiftnumber">0</span>]) {</span>
<span class="swiftcode">                num = n</span>
<span class="swiftcode">            } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">                <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">            }</span>
<span class="swiftcode">        }</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// If there is a second token, then there is</span></span>
<span class="swiftcode">        <span class="swiftcomment">// a denominator value</span></span>
<span class="swiftcode">        <span class="swiftkeyword">if</span> tokens.count &gt; <span class="swiftnumber">1</span> {</span>
<span class="swiftcode">            <span class="swiftcomment">// Try to convert denominator string to integer -</span></span>
<span class="swiftcode">            <span class="swiftcomment">// if not successful, return nil</span></span>
<span class="swiftcode">            <span class="swiftkeyword">if</span> <span class="swiftkeyword">let</span> d = <span class="swiftclass">Int</span>(tokens[<span class="swiftnumber">1</span>]) {</span>
<span class="swiftcode">                den = d</span>
<span class="swiftcode">            } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">                <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">            }</span>
<span class="swiftcode">        }</span>
<span class="swiftcode">        <span class="swiftcomment">// Return new fraction initialising its</span></span>
<span class="swiftcode">        <span class="swiftcomment">// numerator and denominator to values</span></span>
<span class="swiftcode">        <span class="swiftcomment">// read from the string</span></span>
<span class="swiftcode">        <span class="swiftkeyword">return</span> <span class="swiftdefined">Fraction</span>(num: num, den: den)</span>
<span class="swiftcode">    }</span>
<span class="swiftcode">}</span>
</pre>
</div>

		<p>
		Why does class <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em> need to be defined as <em><span class="swiftcode"><span class="swiftkeyword">final</span></span></em>?  This has to do with the fact that Swift is strict with its type checking, and the special <em><span class="swiftcode"><span class="swiftclass">Self</span></span></em> type in the <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em> protocol is not as flexible as one might expect.  An instance of <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em> object responds to method <em><span class="swiftcode">readFromString</span></em>, which returns a <em><span class="swiftcode"><span class="swiftdefined">Fraction</span>?</span></em> object.  <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em> returns optional of its own type from the method, therefore it conforms to <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em>.  Let's imagine now a class, <em><span class="swiftcode">SomeClass</span></em>, that inherits from <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em>.  By the rules of inheritance, <em><span class="swiftcode">SomeClass</span></em> must also conform to <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em>.  In most of the situations this happens naturally without any issue, because subclasses inherit their parent's methods.  However, the inherited <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em> returns a <em><span class="swiftcode"><span class="swiftdefined">Fraction</span>?</span></em> and not a <em><span class="swiftcode">SomeClass?</span></em>.  This doesn't conform to the protocol, because <em><span class="swiftcode">SomeClass</span></em> is not returning <em><span class="swiftcode"><span class="swiftclass">Self</span></span></em>, but an instance of its parent.  This creates a problem for the compiler.  It doesn't matter that a diligent programmer could still override <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em> in the implementation of <em><span class="swiftcode">SomeClass</span></em>.  There is a potential for existence of inherited class that (automatically) inherits compatibility with <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em> protocol, yet does not have a method that returns the correct type.  Swift will have none of that.  One way to resolve this issue is to make <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em> a <em><span class="swiftcode"><span class="swiftkeyword">final</span></span></em> class, meaning no other class can inherit from it.  It's not an ideal solution, and there are probably other ways of resolving this problem, but it's a pretty simple solution that will work for the purpose of this lab.
		</p>

		<p>
		Once you make your <em><span class="swiftcode"><span class="swiftdefined">Fraction</span>?</span></em> conform to <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em>, you can test the parser.  Type/paste in the following code into <em>main.swift</em>:
		</p>

		<div class="codeblock">
<div class="codeblocktitle"><a href="code/02/main_01.swift">main.swift</a></div>
<pre class="linenumbers unselectable" style="float: left;">01:
02:
03:
04:
05:
06:
07:
08:
09:
</pre><pre class="code">
<span class="swiftcode"><span class="swiftkeyword">import</span> Foundation</span>
<span class="swiftcode"></span>
<span class="swiftcode"><span class="swiftkeyword">let</span> expr1: <span class="swiftclass">String</span> = <span class="swiftstring">"-1/2*(3+2/5*(7/8-1/3))-4"</span></span>
<span class="swiftcode"></span>
<span class="swiftcode"><span class="swiftkeyword">if</span> <span class="swiftkeyword">let</span> result = <span class="swiftdefined">Parser</span>&lt;<span class="swiftdefined">Fraction</span>&gt;.evaluate(string: expr1) {</span>
<span class="swiftcode">    <span class="swiftfunction">print</span>(expr1 + <span class="swiftstring">"=</span></span><span class="codeswift">\<span class="swiftstring">(</span>result<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
<span class="swiftcode">} <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">    <span class="swiftfunction">print</span>(<span class="swiftstring">"Syntax error in '</span></span><span class="codeswift">\<span class="swiftstring">(</span>expr1<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">'!"</span>)</span>
<span class="swiftcode">}</span>
</pre>
</div>
		
		<p>
		This short piece of code defines an expression constant and evaluates it.  Evaluation is done by invoking <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em>'s <em><span class="swiftcode">evaluate</span></em> method specifying <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em> as the generic type <em><span class="swiftcode">T</span></em>.  The compiler should not complain, since <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em> conforms to <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em> protocol.  The if statement invokes the <em><span class="swiftcode">evaluate</span></em> method and checks the result for <em><span class="swiftcode">nil</span></em> at the same time.  Run the program, you should get the answer in fraction format.
		</p>
		

		<div class="note">
		<img src="images/note.png" style="width:64px;max:64px">
	
		<p>
		You don't need to understand how the internals of <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em> work in order to use it.  In fact, the point of this exercise is to show that polymorphism allows effective use of complex code while understanding only the protocols involved.  However, in case you're still curious how it works, here's a bit of an explanation.   
		</p>

		<p>
		The parser breaks the string expression into tokens based on the operators it understands: the -,+,*,/ and the brackets.  The token strings are paired with preceding operation for later evaluation.  If a token string doesn't contain any more of the mentioned operators, its value is evaluated using <em><span class="swiftcode">readFromString</span></em> method of the generic type passed in to the parser.  On the other hand, if the token has more operator tokens (like a string within brackets), its value is evaluated by recursively calling the evaluate method on that token.  The order of parsing the expression "-1/2*(3+2/5*(7/8-1/3))-4", with the generic type mapped to a <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em>, is shown in the diagram below.  Each row, going down, corresponds to the level of recursion.  The orange numbers underneath show the <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em> value that is found.  Once all the values are known at given level of recursion, mathematical operations are performed, with multiplication and division taking precedence over addition and subtraction.  You can set "withDebugOption" parameter of the <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em>'s <em><span class="swiftcode">evaluate</span></em> method to <em><span class="swiftcode"><span class="swiftkeyword">true</span></span></em> to trace the evaluations of the string in your output. 

		</p>

		<img class="block" src="images/parser.png" style="max-width:994px;max-height:580px" title="Parsing of string expression">

		<p>
		Since the "/" operator is understood by the <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em>, the token passed in to <em><span class="swiftcode">readFromString</span></em> is always of the "x" format, and never of "x/y" format.  This is highlighted in the evaluated values in the diagram above.  Hence, string "2/5" is broken by the parser into "2" divided by "5".  Individual tokens then get evaluated to <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em>s "2/1" and "5/1", later to be divided.  This is perhaps not the most optimal solution, but it works.  You can't always expect a general framework, such as the <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em> class, to give you optimal code for the specific computation you're interested in.  The point is that, in terms of changes to <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em>, it took little effort to get everything working.
		</p>

		</div>

	  <h3>Parsing complex numbers</h3>

		<p>
		Add the following code to <em>main.swift</em>:
		</p>

		<div class="codeblock">
<div class="codeblocktitle"><a href="code/02/main_02.swift">main.swift</a></div>
<pre class="linenumbers unselectable" style="float: left;"><span class="codeold">01:
</span><span class="codeold">02:
</span><span class="codeold">03:
</span><span class="codeold">04:
</span><span class="codeold">05:
</span><span class="codeold">06:
</span><span class="codeold">07:
</span><span class="codeold">08:
</span><span class="codeold">09:
</span><span class="codeold">10:
</span>11:
12:
13:
14:
15:
16:
17:
</pre><pre class="code">
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">import</span> Foundation</span></span>
<span class="codeold"><span class="swiftcode"></span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">let</span> expr1: <span class="swiftclass">String</span> = <span class="swiftstring">"-1/2*(3+2/5*(7/8-1/3))-4"</span></span></span>
<span class="codeold"><span class="swiftcode"></span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">if</span> <span class="swiftkeyword">let</span> result = <span class="swiftdefined">Parser</span>&lt;<span class="swiftdefined">Fraction</span>&gt;.evaluate(string: expr1) {</span></span>
<span class="codeold"><span class="swiftcode">    <span class="swiftfunction">print</span>(expr1 + <span class="swiftstring">"=</span></span><span class="codeswift">\<span class="swiftstring">(</span>result<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span></span>
<span class="codeold"><span class="swiftcode">} <span class="swiftkeyword">else</span> {</span></span>
<span class="codeold"><span class="swiftcode">    <span class="swiftfunction">print</span>(<span class="swiftstring">"Syntax error in '</span></span><span class="codeswift">\<span class="swiftstring">(</span>expr1<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">'!"</span>)</span></span>
<span class="codeold"><span class="swiftcode">}</span></span>
<span class="codeold"><span class="swiftcode"></span></span>
<span class="swiftcode"><span class="swiftkeyword">let</span> expr2: <span class="swiftclass">String</span> = <span class="swiftstring">"(1.3+2i)*(1.3-2i)"</span></span>
<span class="swiftcode"></span>
<span class="swiftcode"><span class="swiftkeyword">if</span> <span class="swiftkeyword">let</span> result = <span class="swiftdefined">Parser</span>&lt;<span class="swiftdefined">Fraction</span>&gt;.evaluate(string: expr2) {</span>
<span class="swiftcode">    <span class="swiftfunction">print</span>(expr2 + <span class="swiftstring">"=</span></span><span class="codeswift">\<span class="swiftstring">(</span>result<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span>
<span class="swiftcode">} <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">    <span class="swiftfunction">print</span>(<span class="swiftstring">"Syntax error in '</span></span><span class="codeswift">\<span class="swiftstring">(</span>expr2<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">'!"</span>)</span>
<span class="swiftcode">}</span>
</pre>
</div>
		
		<p>
		Run the program&mdash;you'll get a syntax error on the second expression.  This is not surprising, since neither the <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em> nor <em><span class="swiftcode"><span class="swiftdefined">Fraction</span></span></em> understand syntax "2i".  The expression is a computation for magnitude of a complex number.  In order to evaluate it, you'll need to use a <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em> with the <em><span class="swiftcode"><span class="swiftdefined">Complex</span></span></em> class.
		</p>
		
		<p>
		Again, in order for <em><span class="swiftcode"><span class="swiftdefined">Complex</span></span></em> to map to <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em>'s generic type, it needs to conform to the <em><span class="swiftcode"><span class="swiftdefined">StringConvertibleNum</span></span></em> protocol.  Grab your implementation of <em><span class="swiftcode"><span class="swiftdefined">Complex</span></span></em> class from <a href="http://cs.otago.ac.nz/cosc346/labs/lab03/lab03.html">Lab 3</a>.  Once again (if you finished the lab) the functions for the +,-,* and / operators that take <em><span class="swiftcode"><span class="swiftdefined">Complex</span></span></em> objects and return <em><span class="swiftcode"><span class="swiftdefined">Complex</span></span></em> result should be already there.  You only need to implement the <em><span class="swiftcode">readFromString</span></em> method.    
		</p>
		
		<p>
		Implementation of the <em><span class="swiftcode">readFromString</span></em> method for the <em><span class="swiftcode"><span class="swiftdefined">Complex</span></span></em> class is given below.  This method takes advantage of the fact that <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em> breaks tokens of the format "a+bi" into "a" plus "bi".  Hence, the <em><span class="swiftcode">readFromString</span></em> method needs only to recognise if there is an "i" at the end of the string, evaluate the number value to a float, and return the object corresponding to "a+0i" or "0+bi", depending whether "i" was found or not.  Same goes for "a-bi".
		</p>
		
		<div class="codeblock">
<div class="codeblocktitle"><a href="code/02/Complex.swift">Complex.swift</a></div>
<pre class="linenumbers unselectable" style="float: left;">01:
02:
03:
04:
05:
06:
07:
08:
09:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44:
45:
46:
47:
48:
</pre><pre class="code">
<span class="swiftcode"><span class="swiftkeyword">import</span> Foundation</span>
<span class="swiftcode"></span>
<span class="swiftcode"><span class="swiftcomment">/**</span></span>
<span class="swiftcode"><span class="swiftcomment">Represents a complex number</span></span>
<span class="swiftcode"><span class="swiftcomment"></span></span>
<span class="swiftcode"><span class="swiftcomment">*/</span></span>
<span class="swiftcode"><span class="swiftkeyword">final</span> <span class="swiftkeyword">class</span> <span class="swiftdefined">Complex</span> : <span class="swiftclass">CustomStringConvertible</span>, <span class="swiftdefined">StringConvertibleNum</span> {</span>
<span class="swiftcode">    </span>
<span class="swiftcode">    <span class="swiftcomment">/**</span></span>
<span class="swiftcode"><span class="swiftcomment">    Converts string to a Complex object.  Supports string</span></span>
<span class="swiftcode"><span class="swiftcomment">    syntax of the following format:</span></span>
<span class="swiftcode"><span class="swiftcomment">    "a" - converts it to complex number a+0i</span></span>
<span class="swiftcode"><span class="swiftcomment">    "ai" - converts it to complex number 0+ai</span></span>
<span class="swiftcode"><span class="swiftcomment">    </span></span>
<span class="swiftcode"><span class="swiftcomment">    - parameter string: String to convert</span></span>
<span class="swiftcode"><span class="swiftcomment">    - returns: Complex? Complex object read from string, nil if</span></span>
<span class="swiftcode"><span class="swiftcomment">    syntax error in the string</span></span>
<span class="swiftcode"><span class="swiftcomment">    */</span></span>
<span class="swiftcode">    <span class="swiftkeyword">static</span> <span class="swiftkeyword">func</span> readFromString(_ string: <span class="swiftclass">String</span>) -&gt; <span class="swiftdefined">Complex</span>? {</span>
<span class="swiftcode">        <span class="swiftcomment">// Break the string into tokens separated by i symbol</span></span>
<span class="swiftcode">        <span class="swiftkeyword">var</span> tokens = string.components(separatedBy: <span class="swiftstring">"i"</span>)</span>
<span class="swiftcode">        </span>
<span class="swiftcode">        <span class="swiftcomment">// If there is at least one token, then there is</span></span>
<span class="swiftcode">        <span class="swiftcomment">// a numerator value</span></span>
<span class="swiftcode">        <span class="swiftkeyword">if</span> tokens.count &gt; <span class="swiftnumber">0</span> {</span>
<span class="swiftcode">            <span class="swiftcomment">// The token is the number without the i, so can convert it</span></span>
<span class="swiftcode">            <span class="swiftcomment">// to a float value</span></span>
<span class="swiftcode">            <span class="swiftkeyword">let</span> numToken = tokens[<span class="swiftnumber">0</span>]</span>
<span class="swiftcode">            <span class="swiftkeyword">let</span> numFromStr : <span class="swiftclass">Float</span>? = (numToken <span class="swiftkeyword">as</span> <span class="swiftclass">NSString</span>).floatValue;</span>
<span class="swiftcode">            </span>
<span class="swiftcode">            <span class="swiftcomment">// If the conversion of the number to float worked...</span></span>
<span class="swiftcode">            <span class="swiftkeyword">if</span> <span class="swiftkeyword">let</span> num = numFromStr {</span>
<span class="swiftcode">                <span class="swiftcomment">// Check if the token is the same as argument string...</span></span>
<span class="swiftcode">                <span class="swiftkeyword">if</span> numToken == string {</span>
<span class="swiftcode">                    <span class="swiftcomment">// If yes, then it means there was no i in the string...</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">return</span> <span class="swiftdefined">Complex</span>(real: num, imag: <span class="swiftnumber">0</span>.<span class="swiftnumber">0</span>)</span>
<span class="swiftcode">                } <span class="swiftkeyword">else</span> {</span>
<span class="swiftcode">                    <span class="swiftcomment">// If the passed in string had "i" at the end, the</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// separate by string would have removed the i, so the</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// token is not the same as the argument string.</span></span>
<span class="swiftcode">                    <span class="swiftcomment">// The number then is imaginary</span></span>
<span class="swiftcode">                    <span class="swiftkeyword">return</span> <span class="swiftdefined">Complex</span>(real: <span class="swiftnumber">0</span>.<span class="swiftnumber">0</span>, imag: num);</span>
<span class="swiftcode">                }</span>
<span class="swiftcode">            }</span>
<span class="swiftcode">        }</span>
<span class="swiftcode">        <span class="swiftkeyword">return</span> nil</span>
<span class="swiftcode">    }</span>
<span class="swiftcode">}</span>
</pre>
</div>
		
		<p>
		Change the code in <em>main.swift</em> to pass <em><span class="swiftcode"><span class="swiftdefined">Complex</span></span></em> as the generic type when parsing the second expression:  
		</p>

		<div class="codeblock">
<div class="codeblocktitle"><a href="code/02/main_03.swift">main.swift</a></div>
<pre class="linenumbers unselectable" style="float: left;"><span class="codeold">01:
</span><span class="codeold">02:
</span><span class="codeold">03:
</span><span class="codeold">04:
</span><span class="codeold">05:
</span><span class="codeold">06:
</span><span class="codeold">07:
</span><span class="codeold">08:
</span><span class="codeold">09:
</span><span class="codeold">10:
</span><span class="codeold">11:
</span><span class="codeold">12:
</span>13:
<span class="codeold">14:
</span><span class="codeold">15:
</span><span class="codeold">16:
</span><span class="codeold">17:
</span></pre><pre class="code">
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">import</span> Foundation</span></span>
<span class="codeold"><span class="swiftcode"></span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">let</span> expr1: <span class="swiftclass">String</span> = <span class="swiftstring">"-1/2*(3+2/5*(7/8-1/3))-4"</span></span></span>
<span class="codeold"><span class="swiftcode"></span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">if</span> <span class="swiftkeyword">let</span> result = <span class="swiftdefined">Parser</span>&lt;<span class="swiftdefined">Fraction</span>&gt;.evaluate(expr1) {</span></span>
<span class="codeold"><span class="swiftcode">    <span class="swiftfunction">print</span>(expr1 + <span class="swiftstring">"=</span></span><span class="codeswift">\<span class="swiftstring">(</span>result<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span></span>
<span class="codeold"><span class="swiftcode">} <span class="swiftkeyword">else</span> {</span></span>
<span class="codeold"><span class="swiftcode">    <span class="swiftfunction">print</span>(<span class="swiftstring">"Syntax error in '</span></span><span class="codeswift">\<span class="swiftstring">(</span>expr1<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">'!"</span>)</span></span>
<span class="codeold"><span class="swiftcode">}</span></span>
<span class="codeold"><span class="swiftcode"></span></span>
<span class="codeold"><span class="swiftcode"><span class="swiftkeyword">let</span> expr2: <span class="swiftclass">String</span> = <span class="swiftstring">"(1.3+2i)*(1.3-2i)"</span></span></span>
<span class="codeold"><span class="swiftcode"></span></span>
<span class="swiftcode"><span class="swiftkeyword">if</span> <span class="swiftkeyword">let</span> result = <span class="swiftdefined">Parser</span>&lt;<span class="swiftdefined">Complex</span>&gt;.evaluate(expr2) {</span>
<span class="codeold"><span class="swiftcode">    <span class="swiftfunction">print</span>(expr2 + <span class="swiftstring">"=</span></span><span class="codeswift">\<span class="swiftstring">(</span>result<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">"</span>)</span></span>
<span class="codeold"><span class="swiftcode">} <span class="swiftkeyword">else</span> {</span></span>
<span class="codeold"><span class="swiftcode">    <span class="swiftfunction">print</span>(<span class="swiftstring">"Syntax error in '</span></span><span class="codeswift">\<span class="swiftstring">(</span>expr2<span class="swiftstring">)</span></span><span class="swiftcode"><span class="swiftstring">'!"</span>)</span></span>
<span class="codeold"><span class="swiftcode">}</span></span>
</pre>
</div>

		<p>
		Run the program, it should evaluate fine now.  That's how easy it was to create new functionality (parsing of complex numbers) without touching the most complicated part of the code&mdash;the implementation of the parser.  Of course the <em><span class="swiftcode"><span class="swiftdefined">Parser</span></span></em> had to be written in the first place in a way that allows the user to plugin generic objects for reading values from strings and performing basic arithmetic.  But now, you can imagine, it would require relatively little work to create classes that would allow expression evaluation with other numbers: such as binary, hex, and maybe even symbolic expressions. 
		</p>
	
	</div>



	<div class="banner">
		<a href="http://cs.otago.ac.nz/cosc346/labs/../labs.php">COSC346 - Object Oriented Programming and User Interfaces</a>
	</div>
	</body>
</html>
